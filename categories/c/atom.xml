<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C | 不歸錄]]></title>
  <link href="http://tonytonyjan.net/categories/c/atom.xml" rel="self"/>
  <link href="http://tonytonyjan.net/"/>
  <updated>2013-10-23T15:14:52+08:00</updated>
  <id>http://tonytonyjan.net/</id>
  <author>
    <name><![CDATA[大兜]]></name>
    <email><![CDATA[tonytonyjan@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[大兜的 gcc 歷險記]]></title>
    <link href="http://tonytonyjan.net/2012/10/02/dig-gcc-with-tony/"/>
    <updated>2012-10-02T13:13:00+08:00</updated>
    <id>http://tonytonyjan.net/2012/10/02/dig-gcc-with-tony</id>
    <content type="html"><![CDATA[<p>由於不是很清楚 gcc 在編譯 c 文件時到底做了什麼事情，於是展開了深入理解的旅程。從最簡單的 <code>hello.c</code> 開始：</p>

<p>``` c hello.c</p>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char* args[]){
  printf(&ldquo;Hello, world!&rdquo;);
}
```</p>

<p>在編譯之前，讓我們回顧一下編譯的步驟：</p>

<table>
<thead>
<tr>
<th>步驟                   </th>
<th> 指令                      </th>
<th> 中出檔</th>
</tr>
</thead>
<tbody>
<tr>
<td>                       </td>
<td>                           </td>
<td> 原始碼</td>
</tr>
<tr>
<td>前處理（preprocessing）</td>
<td> gcc -E hello.c -o hello.i </td>
<td>   ↓↓</td>
</tr>
<tr>
<td>                       </td>
<td>                           </td>
<td> 原始碼（標頭被展開）</td>
</tr>
<tr>
<td>編譯（compiling）      </td>
<td> gcc -S hello.i -o hello.s </td>
<td>   ↓↓</td>
</tr>
<tr>
<td>                       </td>
<td>                           </td>
<td> 組合語言</td>
</tr>
<tr>
<td>組譯（assembling）     </td>
<td> gcc -c hello.s -o hello.o </td>
<td>   ↓↓</td>
</tr>
<tr>
<td>                       </td>
<td>                           </td>
<td> 機器碼</td>
</tr>
<tr>
<td>連結（linking）        </td>
<td> ld &hellip; （暫略）           </td>
<td>   ↓↓</td>
</tr>
<tr>
<td>                       </td>
<td>                           </td>
<td> 可執行機器碼</td>
</tr>
</tbody>
</table>


<pre><code>-E 僅作預先處理，不進行編譯、組譯和連結
-S 編譯到組合語言，不進行組譯和連結
-c 編譯、組譯到目的程式碼，不進行連結
</code></pre>

<p>看到鍵盤上的 <code>Esc</code> 了嗎？那正是編譯步驟，是不是超好記的。</p>

<!-- more -->


<h2>前處理（Preprocessing）</h2>

<pre><code>gcc -E hello.c -o hello.i
</code></pre>

<p>在這個步驟裡面會把標頭（header）一一展開，即範例中的 <code>stdio.h</code>，展開之後取代 <code>#include&lt;stdio.h&gt;</code>，我的 <code>hello.i</code> 就多了四百多行，看起來像是這樣子：</p>

<pre><code>// 以上 432 行略，建議自己 DIY 看看
int main(int argc, char* args[]){
  printf("Hello, world!");
}
</code></pre>

<h2>編譯</h2>

<pre><code>gcc -S hello.i -o hello.s
</code></pre>

<table>
<thead>
<tr>
<th>步驟                              </th>
<th> 輸出檔</th>
</tr>
</thead>
<tbody>
<tr>
<td>                                  </td>
<td> Sequence of characters</td>
</tr>
<tr>
<td>lexical analysis                  </td>
<td> ↓↓</td>
</tr>
<tr>
<td>                                  </td>
<td> Sequence of lexical elements</td>
</tr>
<tr>
<td>parsing                           </td>
<td> ↓↓</td>
</tr>
<tr>
<td>                                  </td>
<td> Syntax tree</td>
</tr>
<tr>
<td>semantic analysis                 </td>
<td> ↓↓</td>
</tr>
<tr>
<td>                                  </td>
<td> Annotated syntax tree</td>
</tr>
<tr>
<td>generation of intermediate code   </td>
<td> ↓↓</td>
</tr>
<tr>
<td>                                  </td>
<td> Sequence of IL</td>
</tr>
<tr>
<td>optimization of intermediate code </td>
<td> ↓↓</td>
</tr>
<tr>
<td>                                  </td>
<td> Sequence of IL</td>
</tr>
<tr>
<td>generation of pseudo code         </td>
<td> ↓↓</td>
</tr>
<tr>
<td>                                  </td>
<td> Assembly program</td>
</tr>
</tbody>
</table>


<p>編譯就是把原始碼轉換成目的語言的動作（通常就是組合語言）</p>

<p><code>nasm hello.s
  .file "hello.c"
  .def  ___main;  .scl  2;  .type 32; .endef
  .section .rdata,"dr"
LC0:
  .ascii "Hello, world!\0"
  .text
  .globl  _main
  .def  _main;  .scl  2;  .type 32; .endef
_main:
LFB6:
  .cfi_startproc
  pushl %ebp
  .cfi_def_cfa_offset 8
  .cfi_offset 5, -8
  movl  %esp, %ebp
  .cfi_def_cfa_register 5
  andl  $-16, %esp
  subl  $16, %esp
  call  ___main
  movl  $LC0, (%esp)
  call  _printf
  leave
  .cfi_restore 5
  .cfi_def_cfa 4, 4
  ret
  .cfi_endproc
LFE6:
  .def  _printf;  .scl  2;  .type 32; .endef
</code></p>

<h2>組譯</h2>

<pre><code>gcc -c hello.s -o hello.o
</code></pre>

<p>組譯之後會產生目的檔（hello.o），裡面全都是機器碼。</p>

<p>但因為我們還少了連結的動作，所以 <code>hello.o</code> 還無法被執行。</p>

<h2>連結</h2>

<pre><code>ld -o hello.exe c:/mingw/bin/../lib/gcc/mingw32/4.7.0/../../../crt2.o hello.o -lmingw32 -lmoldname -lmingwex -lmsvcrt -ladvapi32 -lshell32 -luser32 -lkernel32
</code></pre>

<p>你大概感到好奇為什麼 <code>hello.o</code> 和 <code>hello.exe</code> 平平都是機器碼，少了連結，前者就無法執行。</p>

<p>這個程式就只是在黑窗上面印出一個「Hello, world!」，但我們並沒有真的去實做 IO 處理或是送訊號去顯卡，因為這些繁瑣的工作全交給 <code>printf</code> 完成了。然而在編譯的過程，編譯器並不知道 <code>printf</code> 編譯好的機器碼放在哪裡（可能在一個 <code>.obj</code> 或 <code>.lib</code> 裡面），所以在產生目的檔時，會在 <code>printf</code> 的進入點留位置給連結器（linker）去做填空，等連結器收集了所有需要的機器碼之後，才將他們填上。</p>

<p>這也是為什麼可執行檔會比原來的原始碼大很多，因為連結器插入了很多來自其他檔案的機器碼。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[～C語言程式設計～一維陣列 巴斯卡三角形～]]></title>
    <link href="http://tonytonyjan.net/2010/10/27/44/"/>
    <updated>2010-10-27T08:04:06+08:00</updated>
    <id>http://tonytonyjan.net/2010/10/27/44</id>
    <content type="html"><![CDATA[<p>很久沒有寫這種文章了XD</p>

<p>這學期還是當蔡神的小助教，有一個作業是寫巴斯卡三角形～想起大一剛進來的時候也有寫過，連程式是什麼都不知道，寫起來很吃力，今天再寫一次，果然三兩下就出來了，這就是所謂的進步嗎XD</p>

<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<p>void fun(int);
int main(void){</p>

<pre><code>int in;
while(1==1){
    printf("Give me a number 1~20: ");
    scanf("%d", &amp;in);
    fun(in);
}
return 0;
</code></pre>

<p>}
void fun(int n){</p>

<pre><code>if(n&gt;20 || n &lt;1){
    puts("range: 1~20");
    return;
}
int buf[20]={1};
int i, j;
for(i=0;i&lt;n;i++){
    for(j=i;j&gt;0;j--) buf[j] = buf[j] + buf[j-1];
    for(j=0;j&lt;n-i;j++)printf("     ");
    for(j=0;j&lt;=i;j++) printf("%5d     ", buf[j]);
    printf("\n");
}
</code></pre>

<p>}
```</p>

<p>印出來很漂亮吧？XD</p>

<p>{% img /images/slum-area/37_0.png %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[～C語言程式設計～電腦猜數字～]]></title>
    <link href="http://tonytonyjan.net/2008/11/29/127/"/>
    <updated>2008-11-29T08:22:05+08:00</updated>
    <id>http://tonytonyjan.net/2008/11/29/127</id>
    <content type="html"><![CDATA[<p>這次換人想題目給電腦猜，而且<span style="font-size: 36pt; color: #ff0000;"><b>保證七次內</b></span>可以猜的出來，想下載的人<a href="http://www.cs.nctu.edu.tw/~whchien/coding/PCGuessNum.exe">請點我</a>，以後要跟別人玩猜數字遊戲就拿著個當外掛就好了XDD</p>


<p>這次費了我很大的功夫在想演算法，對於一個超級不會玩猜數字遊戲的人，要他想演算法實在是太吃力了......其實若要我自己來猜的話大概都要猜個40、50次才答對......最後我忍不住去請教隔壁寢的猜數字大神才知道猜數字的訣竅。（人家猜個五六次就猜出來了！）</p>


<p>既然已經知道訣竅，只要把方法化為程式碼就大功告成啦XD</p>


<p>另外值得一提的是，我用了一個新的防呆措施，運用do{}while(); 先讀取再判斷，如果使用者亂打就再重複一直讀取，讀取至使用者打對為止，這個方法我覺得很簡潔^^（自以為）</p>


<p>至於怎麼刪去不可能的答案組合成新的答案庫，是先判斷所有的答案（如果是一開始，當然，就要判斷5040次），找尋不可能的答案，找到之後，就把這個答案之後所有的答案往前遞移一個答案，這和隨機不重複用的是一樣的方法。</p>


<p>總之我覺得這是個滿好玩的題目^^</p>


<p>{% img /images/slum-area/110_0.jpg %}</p>


<p>{% codeblock lang:c %}</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;stdlib.h></h1>

<h1>include&lt;string.h></h1>

<h1>include&lt;time.h></h1>

<p>void intro(void);  //介紹文函數
void prepare(void);  //準備工作之函數
void ask(void);  //電腦問之函數
void answer(void);  //人類答幾a幾b之函數
void think(void);  //電腦思考之函數（其實就是從答案庫中排除不可能的答案）
void menu(void);  //選單之函數
int answerBase[5040][4];  /*答案庫，會裝入所有重複的四位數，從1234到9876</p>

<pre><code>                        5040是因為10*9*8*7，4是因為每組答案是一個四位數*/ 
</code></pre>

<p>int isOver,restart;  //當作布林值，判斷是否遊戲結束以及是否要繼續玩
int remain;  //答案庫裡面的答案數
int a,b;  //拿來裝使用者回答的幾a幾b
int randNum;  //裝亂數，隨機從答案庫裡面拿答案
int main(void){</p>

<pre><code>intro(); 
while(1==1){
    prepare(); 
    while(!isOver){
        ask();
        answer();
        if(isOver) break;
        think();
        printf("------------------\n");
    }
    menu(); 
    if(!restart) break;
}
getchar();
return 0;
</code></pre>

<p>}
/<strong><strong><strong> 準備工作之函數 </strong></strong></strong>/
void prepare(void){</p>

<pre><code>int i,tmp,unit_1,unit_10,unit_100,unit_1000;
remain=5040; 
tmp=0;  //tmp只是一個拿來計數變數 
isOver=0;  //判斷結束與否 
for(i=0;i&lt;10000;i++){  //這個for產生答案庫 
    unit_1 = (i/1)%10;  //以下四行把四位數拆成四個各位數分別存到四個變數 
    unit_10 = (i/10)%10;
    unit_100 = (i/100)%10;
    unit_1000 = (i/1000)%10;
    if(unit_1!=unit_10 &amp;&amp; unit_1!=unit_100 &amp;&amp; unit_1!=unit_1000 &amp;&amp; unit_10!=unit_100 &amp;&amp; unit_10!=unit_1000 &amp;&amp; unit_100!=unit_1000){
        answerBase[tmp][0] = unit_1000;
        answerBase[tmp][1] = unit_100;
        answerBase[tmp][2] = unit_10;
        answerBase[tmp][3] = unit_1;
        tmp++;
    }
}
</code></pre>

<p>}
/<strong><strong><strong> 電腦問之函數 </strong></strong></strong>/
void ask(void){</p>

<pre><code>int i;
printf("大兜蟲：請問是");
srand(time(0));
while(1==1){
    randNum=0;
    for(i=0;i&lt;4;i++){
        randNum *= 10;
        randNum += rand()%10;
    }
    if(randNum&lt;remain) break;
}
for(i=0;i&lt;4;i++) printf("%d",answerBase[randNum][i]);
printf("?\n");
</code></pre>

<p>}
/<strong><strong><strong> 人類答之函數 </strong></strong></strong>/
void answer(void){</p>

<pre><code>char input[500];
int right=0;  //當布林值，判斷是否正確的輸入 
do{  //取得a,b值 
    do{  //取得a值
        printf("A:");
        fgets(input,sizeof(input),stdin);
        *(input+strlen(input)-1)='\0';
        if(strlen(input)==1 &amp;&amp; *input-'0'&lt;= 9 &amp;&amp; *input-'0'&gt;=0){
            a = *input-'0';
            right = 1;
        }else printf("輸入錯誤\n\n");
    }while(!right);
    do{  //取得b值 
        printf("B:");
        fgets(input,sizeof(input),stdin);
        *(input+strlen(input)-1)='\0';
        if(strlen(input)==1 &amp;&amp; *input-'0'&lt;= 9 &amp;&amp; *input-'0'&gt;=0){
            b = *input-'0';
            right = 1;
        }else printf("輸入錯誤\n\n");
    }while(!right);

    if(a+b&gt;4){  //如果a和b相加大於4當然就錯啦～ 
        printf("輸入錯誤\n\n");
        right = 0;
    }
}while(!right);
if(a==4){
    printf("大兜蟲：耶～答對了！\n");
    isOver=1;
}else if(remain==1){  //如果答案庫只剩一個答案，但是這答案還是錯的，就是玩家作弊！ 
    printf("大兜蟲：你作弊！= =+\n");
    isOver=1;
}
</code></pre>

<p>}
/<strong><strong><strong> 電腦思考之函數 </strong></strong></strong>/
void think(void){</p>

<pre><code> int i,j,k,aa,bb;
 int refer[4];
 for(i=0;i&lt;4;i++){
     refer[i]=answerBase[randNum][i];
 }
 for(i=0;i&lt;remain;i++){
     aa = bb = 0;  //填裝a值和b值，但要區別於之前的人類輸入的a值b值 
     for(j=0;j&lt;4;j++){  //以下兩個for用來比對第i個答案和亂數取的答案的是幾a幾b 
         for(k=0;k&lt;4;k++){
             if(answerBase[i][j]==refer[k]){
                 if(j==k) aa++;
                 else bb++; 
             }
         }
     }
     if(!((aa==a)&amp;&amp;(bb==b))){  //把a值b值相等的答案保留下來 
         for(j=i;j&lt;remain;j++){  //開始搬運 
             for(k=0;k&lt;4;k++){
                 answerBase[j][k]=answerBase[j+1][k];
             }
         }
         remain--;
         i--;
     }
 }
 if(remain==0){  //發現沒有答案符合玩家想的數字，就是玩家作弊！
    printf("大兜蟲：你作弊！= =+\n");
    isOver=1;
 }
</code></pre>

<p>}
/<strong><strong><strong> 選單之函數 </strong></strong></strong>/
void menu(void){</p>

<pre><code>char input[500];
int right = 0;
do{
    printf("大兜蟲：是否重新？y/n");
    fgets(input,sizeof(input),stdin);
    *(input+strlen(input)-1)='\0';
    if(strlen(input)==1 &amp;&amp; (*input == 'y' || *input == 'Y')){
        printf("\n------------------\n"); 
        restart = 1;
        right = 1;
    }else if(strlen(input)==1 &amp;&amp; (*input == 'n' || *input == 'N')){
        printf("大兜蟲：遊戲結束，拜拜～～");
        restart = 0;
        right = 1; 
    }else printf("輸入錯誤\n\n");
}while(!right);    
</code></pre>

<p>}
/<strong><strong><strong> 介紹函數 </strong></strong></strong>/
void intro(void){</p>

<pre><code>printf("***************************************************\n");
printf("***************************************************\n");
printf("**                                               **\n");
printf("**  大兜蟲猜數字遊戲(猜人) ver1.0                **\n");
printf("**                                               **\n");
printf("**  遊戲規則：                                   **\n");
printf("**  1.每回合大兜蟲會猜一個四位數字               **\n");
printf("**  2.A的次數代表大兜蟲猜對了幾個數字且位置正確  **\n");
printf("**  3.B的次數代表大兜蟲猜對了幾個數字但位置不對  **\n");
printf("**  4.你必須告訴大兜蟲A和B的值                   **\n");
printf("**  5.七回合內必可猜出答案                       **\n");
printf("**  6.Enjoy！                                    **\n");
printf("**                                               **\n");
printf("***************************************************\n");
printf("***************************************************\n");
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[～C語言程式設計～數字大戰～]]></title>
    <link href="http://tonytonyjan.net/2008/11/08/130/"/>
    <updated>2008-11-08T08:29:20+08:00</updated>
    <id>http://tonytonyjan.net/2008/11/08/130</id>
    <content type="html"><![CDATA[<p>下載執行檔請<a href="http://www.cs.nctu.edu.tw/~whchien/coding/BatNum.exe">點我</a>
花了一個早上&hellip;終於完成啦&lt;</p>

<p>{% img /images/slum-area/113_0.jpg %}</p>

<p>下面是原始碼，可是作者砍掉小禮物的部份囉（怎麼可以輕易洩漏呢^^）</p>

<p><b><span style="font-size: 14pt;">想知道小禮物是什麼的人就憑自己的實力獲勝吧XD</span></b></p>

<p>而各位應該也發現語法框被分成一塊一塊了，因為有字數限制&hellip;不分開的話後面的字會不見&hellip;囧</p>

<p>有任何問題或建議儘管指教吧^^</p>

<p>{% codeblock lang:c %}</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;stdlib.h></h1>

<h1>include&lt;string.h></h1>

<h1>include&lt;time.h></h1>

<p>/<strong><em>宣告函數</em></strong>/
void intro(void);  //介紹文
int getRand(int,int);  //亂數函數
void prepare(void);  //準備工作
void goPlay(void);  //遊戲進行
void pcPlay(void);  //輪電腦玩
void manPlay(void);  //輪人類玩
void menu(void);  //選單
/<strong><em>宣告變數</em></strong>/
int stoneNum;  //石頭數
int takeNum;  //取石頭的上限
int ifLastIsWin;  //布林值，是否拿最後一顆的人贏
int restart;  //布林值，是否要繼續玩
int ifOver;  //遊戲結束
int remain;  //剩下的石頭
char input[500];  //放使用者輸入的東西
int main(void){  //主程式只有九行XD</p>

<pre><code>intro();
countWin=0;
restart = 1;
while(restart){
    prepare();
    goPlay();
}
return 0;
</code></pre>

<p>}
/<strong><strong><strong> 介紹文 </strong></strong></strong>/
void intro(void){</p>

<pre><code>printf("************************************************\n");
printf("************************************************\n");
printf("**                                            **\n");
printf("**  大兜蟲數字大戰遊戲 Ver1.0                 **\n");
printf("**                                            **\n");
printf("**  操作說明：                                **\n");
printf("**                                            **\n");
printf("**  1.遊戲一開始會設定石頭數，取石頭的上限數  **\n");
printf("**    和規定拿到最後一顆石頭的人獲勝或失敗    **\n");
printf("**                                            **\n");
printf("**  2.選擇誰先開始，電腦或玩家                **\n");
printf("**                                            **\n");
printf("**  3.輪流拿石頭                              **\n");
printf("**                                            **\n");
printf("**  4.祝好運！                                **\n");
printf("**                                            **\n");
printf("**  ps. 連贏三次有神秘獎品！                  **\n");
printf("**                                            **\n");
printf("************************************************\n");
printf("************************************************\n");
</code></pre>

<p>}
/<strong><strong><strong> 準備工作 </strong></strong></strong>/
void prepare(void){</p>

<pre><code>stoneNum = getRand(20,40);  //這六列是事前準備工作 
takeNum = getRand(4,10);
ifLastIsWin = getRand(0,1);
remain = stoneNum;
ifOver = 0;
</code></pre>

<p>}
/<strong><strong><strong> 遊戲進行函數 </strong></strong></strong>/
void goPlay(void){</p>

<pre><code>if(ifLastIsWin){
    printf("\n現在有%d顆石頭，最多可拿%d顆，拿到最後一顆的人就贏！\n",stoneNum,takeNum);
}else{
    printf("\n現在有%d顆石頭，最多可拿%d顆，拿到最後一顆的人就輸！\n",stoneNum,takeNum);
}

int boolin =0;
printf("想先玩請輸入'1'，後玩請輸入'2': ");
while(!boolin){
    boolin = 1;
    fgets(input,sizeof(input),stdin);
    *(input+strlen(input)-1)='\0';
    printf("\n");
    if(*input == '1'&amp;&amp; strlen(input)==1 ){
        while(!ifOver){
            manPlay();
            if(ifOver) break;       
            pcPlay();
            if(ifOver) break;
        }
    }else if(*input == '2'&amp;&amp; strlen(input)==1){
        while(!ifOver){
            pcPlay();
            if(ifOver) break;
            manPlay();
            if(ifOver) break;
        }
    }else{
        printf("錯誤：請輸入1或2\n");
        boolin *=0;
    }
}
</code></pre>

<p>}
/<strong><strong><strong> 輪電腦玩 </strong></strong></strong>/
void pcPlay(void){</p>

<pre><code>int d;
if(ifLastIsWin){
    if(remain &lt;= takeNum){
        d = remain;
        remain -= remain;
        ifOver=1;
        printf("電腦拿走了%d顆，還剩下%d顆石頭\n",d,remain);
        printf("\n電腦獲勝！\n");
        menu();
    }else if(remain%(takeNum +1) == 0){
        d = getRand(1,takeNum);
        remain -= d;
        printf("電腦拿走了%d顆，還剩下%d顆石頭\n",d,remain);   
    }else{
        d = (remain%(takeNum +1));
        remain -= d;
        printf("電腦拿走了%d顆，還剩下%d顆石頭\n",d,remain);
    }

}else{
    if(remain == 1){
        remain -= 1;
        ifOver=1;
        printf("電腦拿走了1顆，還剩下%d顆石頭\n",remain);
        printf("\n玩家獲勝！\n");
        menu();
    }else if(remain%(takeNum +1) == 1){
        d = getRand(1,takeNum);
        remain -= d;
        printf("電腦拿走了%d顆，還剩下%d顆石頭\n",d,remain);
    }else if(remain%(takeNum +1) == 0){
        remain -= takeNum;
        printf("電腦拿走了%d顆，還剩下%d顆石頭\n",takeNum,remain);
    }else{
        d = (remain%(takeNum +1) - 1);
        remain -= d;
        printf("電腦拿走了%d顆，還剩下%d顆石頭\n",d,remain);
    }
} 
</code></pre>

<p>}
/<strong><strong><strong> 輪人類玩 </strong></strong></strong>/
void manPlay(void){</p>

<pre><code>char input[500];
int i,input_int;
int boolin = 0;
while(!boolin){
    boolin =1;
    printf("\n\n拿幾顆石頭？");
    fgets(input,sizeof(input),stdin);
    *(input + strlen(input) -1) = '\0';
    for(i=0;i&lt;strlen(input);i++){
        if(!(*(input+i) &gt;= '0' &amp;&amp; *(input+i) &lt;= '9')){
            printf("錯誤：請輸入數字0~9\n");
            boolin *=0; 
            break;
        }
    }
    if(!boolin) continue;
    input_int = atoi(input);
    if(!(input_int&gt;=1 &amp;&amp; input_int &lt;= takeNum &amp;&amp; input_int &lt;= remain)){
        printf("錯誤：不接受零、負數和太大的數\n");
        boolin*=0;
    }
    if(!boolin) continue;
}
remain -= input_int;
if(remain&gt;0){
    printf("玩家拿走了%d顆，還剩下%d顆石頭\n",input_int,remain);
}else if(ifLastIsWin){
    ifOver=1;
    printf("\n玩家獲勝了！\n");
    menu();

}else{
    ifOver=1;
    printf("\n電腦獲勝了！\n");
    menu();
} 
</code></pre>

<p>}
/<strong><strong><strong> 選單函數 </strong></strong></strong>/
void menu(void){</p>

<pre><code> printf("是否繼續？y/n：");
 fgets(input,sizeof(input),stdin);
 *(input + strlen(input) -1) = '\0';
 if(*input == 'y' &amp;&amp; strlen(input) == 1){
     restart = 1;
 }else if(*input == 'n' &amp;&amp; strlen(input) == 1){
     restart = 0;
 }else{
     menu();
 }
</code></pre>

<p>}
/<strong><strong><strong> 亂數函數 </strong></strong></strong>/
int getRand(int min, int max){</p>

<pre><code>srand(time(0));
return rand()%(max-min+1)+min;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[～C語言程式設計～亂數不重複函數～]]></title>
    <link href="http://tonytonyjan.net/2008/11/07/131/"/>
    <updated>2008-11-07T08:39:12+08:00</updated>
    <id>http://tonytonyjan.net/2008/11/07/131</id>
    <content type="html"><![CDATA[<p>今天完成的XDD  還是熱的
這大概是黃金版本了XD(自以為)
放上來當作開放式原碼吧^^～
想套的人可以拿去=3=</p>

<p>ps.函數什麼東西都可以回傳，包括指標> &lt;</p>

<p>使用方法：
1.在main之前先宣告 int* getRand(int,int,int);
2.在main後面複製貼上函數
3.在main裡呼叫時請寫下面兩行：</p>

<p>{% codeblock lang:c %}
int <em>randNum;  //這個等等要拿來指向getRand傳回的東西
randNum = getRand(MIN,MAX,NUM);  //randNum指向getRand回傳的指標
/</em>MIN放入最小值，MAX放最大值，NUM放你想要幾個亂數
{% endcodeblock %}</p>

<p>例如：</p>

<p>{% codeblock lang:c %}
int *randNum;
randNum = getRand(1,42,6);
//這樣就是樂透開獎啦～～～
{% endcodeblock %}</p>

<p>而得到的六個亂數會被放在randNum[0],ransNum[1],randNum[2]&hellip;randNum[5]</p>

<p>下面是原碼：</p>

<p>{% codeblock lang:c %}</p>

<h1>include&amp;lt;stdio.h&amp;gt;</h1>

<h1>include&amp;lt;stdlib.h&amp;gt;</h1>

<h1>include&amp;lt;time.h&amp;gt;</h1>

<h1>define MIN 1  //代表不重複亂數的最小值</h1>

<h1>define MAX 42  //代表不重複亂數的最大值</h1>

<h1>define NUM 6  //代表需要幾個不重複亂數的個數</h1>

<p>//例如這個預設值代表從1到42選6個不重複的亂數（就是樂透開獎啦！）
int* getRand(int,int,int);  //宣告一個函數可以input三個整數然後回傳一個整數指標
int main(void){</p>

<pre><code>int *randNum;  //這個等等要拿來指向getRand傳回的東西 
int i;  //迴圈專用 
randNum = getRand(MIN,MAX,NUM);  //randNum指向getRand回傳的指標
for(i=0;i&amp;amp;lt;NUM;i++){  //印出來
    printf("%d\n",*(randNum+i));
}
getchar();
return 0;
</code></pre>

<p>}
int* getRand(int min, int max, int num){</p>

<pre><code>int tol = max - min +1;  //算出總數
int a[30000];  //放min~max的所有數字 
static int b[30000];  //放取出的亂數 
int i,j;
for(i=0;i&amp;amp;lt;tol;i++){  //跟電腦要記憶格放數字，從小排到大放進a[0]~a[tol-1] 
    *(a+i) = min+i;
}
srand(time(0));
int ctr;  //這只是個容器，拿來裝a[n]裡的n，而這個n是用亂數製造的 
for(i=0;i&amp;amp;lt;num;i++){
    ctr = rand()%(tol-i);
    b[i] = a[ctr];  //把抓好的亂數丟到b裡面 
    for(j=ctr;j&amp;amp;lt;(tol-1-i);j++){  //這是整個不重複亂數函數的經髓所在！
        a[j] = a[j+1];  //很微妙的通通往前移動一格 
    }
}
return b;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
